// Code generated by Wire protocol buffer compiler, do not edit.
// Source file: gtfs-realtime.proto
package com.google.transit.realtime;

import com.squareup.wire.EnumAdapter;
import com.squareup.wire.FieldEncoding;
import com.squareup.wire.Message;
import com.squareup.wire.ProtoAdapter;
import com.squareup.wire.ProtoReader;
import com.squareup.wire.ProtoWriter;
import com.squareup.wire.WireEnum;
import com.squareup.wire.WireField;
import com.squareup.wire.internal.Internal;
import java.io.IOException;
import java.lang.Integer;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import java.util.List;
import okio.ByteString;

/**
 *
 * Entities used in the feed.
 *
 * Realtime update of the progress of a vehicle along a trip.
 * Depending on the value of ScheduleRelationship, a TripUpdate can specify:
 * - A trip that proceeds along the schedule.
 * - A trip that proceeds along a route but has no fixed schedule.
 * - A trip that have been added or removed with regard to schedule.
 *
 * The updates can be for future, predicted arrival/departure events, or for
 * past events that already occurred.
 * Normally, updates should get more precise and more certain (see
 * uncertainty below) as the events gets closer to current time.
 * Even if that is not possible, the information for past events should be
 * precise and certain. In particular, if an update points to time in the past
 * but its update's uncertainty is not 0, the client should conclude that the
 * update is a (wrong) prediction and that the trip has not completed yet.
 *
 * Note that the update can describe a trip that is already completed.
 * To this end, it is enough to provide an update for the last stop of the trip.
 * If the time of that is in the past, the client will conclude from that that
 * the whole trip is in the past (it is possible, although inconsequential, to
 * also provide updates for preceding stops).
 * This option is most relevant for a trip that has completed ahead of schedule,
 * but according to the schedule, the trip is still proceeding at the current
 * time. Removing the updates for this trip could make the client assume
 * that the trip is still proceeding.
 * Note that the feed provider is allowed, but not required, to purge past
 * updates - this is one case where this would be practically useful.
 */
public final class TripUpdate extends Message<TripUpdate, TripUpdate.Builder> {
  public static final ProtoAdapter<TripUpdate> ADAPTER = new ProtoAdapter_TripUpdate();

  private static final long serialVersionUID = 0L;

  public static final Long DEFAULT_TIMESTAMP = 0L;

  public static final Integer DEFAULT_DELAY = 0;

  /**
   * The Trip that this message applies to. There can be at most one
   * TripUpdate entity for each actual trip instance.
   * If there is none, that means there is no prediction information available.
   * It does *not* mean that the trip is progressing according to schedule.
   */
  @WireField(
      tag = 1,
      adapter = "com.google.transit.realtime.TripDescriptor#ADAPTER",
      label = WireField.Label.REQUIRED
  )
  public final TripDescriptor trip;

  /**
   * Additional information on the vehicle that is serving this trip.
   */
  @WireField(
      tag = 3,
      adapter = "com.google.transit.realtime.VehicleDescriptor#ADAPTER"
  )
  public final VehicleDescriptor vehicle;

  /**
   * Updates to StopTimes for the trip (both future, i.e., predictions, and in
   * some cases, past ones, i.e., those that already happened).
   * The updates must be sorted by stop_sequence, and apply for all the
   * following stops of the trip up to the next specified one.
   *
   * Example 1:
   * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
   * delay of 0 for stop_sequence of the current stop means that the trip is
   * exactly on time.
   *
   * Example 2:
   * For the same trip instance, 3 StopTimeUpdates are provided:
   * - delay of 5 min for stop_sequence 3
   * - delay of 1 min for stop_sequence 8
   * - delay of unspecified duration for stop_sequence 10
   * This will be interpreted as:
   * - stop_sequences 3,4,5,6,7 have delay of 5 min.
   * - stop_sequences 8,9 have delay of 1 min.
   * - stop_sequences 10,... have unknown delay.
   */
  @WireField(
      tag = 2,
      adapter = "com.google.transit.realtime.TripUpdate$StopTimeUpdate#ADAPTER",
      label = WireField.Label.REPEATED
  )
  public final List<StopTimeUpdate> stop_time_update;

  /**
   * Moment at which the vehicle's real-time progress was measured. In POSIX
   * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
   */
  @WireField(
      tag = 4,
      adapter = "com.squareup.wire.ProtoAdapter#UINT64"
  )
  public final Long timestamp;

  /**
   * The current schedule deviation for the trip.  Delay should only be
   * specified when the prediction is given relative to some existing schedule
   * in GTFS.
   *
   * Delay (in seconds) can be positive (meaning that the vehicle is late) or
   * negative (meaning that the vehicle is ahead of schedule). Delay of 0
   * means that the vehicle is exactly on time.
   *
   * Delay information in StopTimeUpdates take precedent of trip-level delay
   * information, such that trip-level delay is only propagated until the next
   * stop along the trip with a StopTimeUpdate delay value specified.
   *
   * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
   * value indicating when the delay value was last updated, in order to
   * evaluate the freshness of the data.
   *
   * NOTE: This field is still experimental, and subject to change. It may be
   * formally adopted in the future.
   */
  @WireField(
      tag = 5,
      adapter = "com.squareup.wire.ProtoAdapter#INT32"
  )
  public final Integer delay;

  public TripUpdate(TripDescriptor trip, VehicleDescriptor vehicle,
      List<StopTimeUpdate> stop_time_update, Long timestamp, Integer delay) {
    this(trip, vehicle, stop_time_update, timestamp, delay, ByteString.EMPTY);
  }

  public TripUpdate(TripDescriptor trip, VehicleDescriptor vehicle,
      List<StopTimeUpdate> stop_time_update, Long timestamp, Integer delay,
      ByteString unknownFields) {
    super(ADAPTER, unknownFields);
    this.trip = trip;
    this.vehicle = vehicle;
    this.stop_time_update = Internal.immutableCopyOf("stop_time_update", stop_time_update);
    this.timestamp = timestamp;
    this.delay = delay;
  }

  @Override
  public Builder newBuilder() {
    Builder builder = new Builder();
    builder.trip = trip;
    builder.vehicle = vehicle;
    builder.stop_time_update = Internal.copyOf("stop_time_update", stop_time_update);
    builder.timestamp = timestamp;
    builder.delay = delay;
    builder.addUnknownFields(unknownFields());
    return builder;
  }

  @Override
  public boolean equals(Object other) {
    if (other == this) return true;
    if (!(other instanceof TripUpdate)) return false;
    TripUpdate o = (TripUpdate) other;
    return unknownFields().equals(o.unknownFields())
        && trip.equals(o.trip)
        && Internal.equals(vehicle, o.vehicle)
        && stop_time_update.equals(o.stop_time_update)
        && Internal.equals(timestamp, o.timestamp)
        && Internal.equals(delay, o.delay);
  }

  @Override
  public int hashCode() {
    int result = super.hashCode;
    if (result == 0) {
      result = unknownFields().hashCode();
      result = result * 37 + trip.hashCode();
      result = result * 37 + (vehicle != null ? vehicle.hashCode() : 0);
      result = result * 37 + stop_time_update.hashCode();
      result = result * 37 + (timestamp != null ? timestamp.hashCode() : 0);
      result = result * 37 + (delay != null ? delay.hashCode() : 0);
      super.hashCode = result;
    }
    return result;
  }

  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    builder.append(", trip=").append(trip);
    if (vehicle != null) builder.append(", vehicle=").append(vehicle);
    if (!stop_time_update.isEmpty()) builder.append(", stop_time_update=").append(stop_time_update);
    if (timestamp != null) builder.append(", timestamp=").append(timestamp);
    if (delay != null) builder.append(", delay=").append(delay);
    return builder.replace(0, 2, "TripUpdate{").append('}').toString();
  }

  public static final class Builder extends Message.Builder<TripUpdate, Builder> {
    public TripDescriptor trip;

    public VehicleDescriptor vehicle;

    public List<StopTimeUpdate> stop_time_update;

    public Long timestamp;

    public Integer delay;

    public Builder() {
      stop_time_update = Internal.newMutableList();
    }

    /**
     * The Trip that this message applies to. There can be at most one
     * TripUpdate entity for each actual trip instance.
     * If there is none, that means there is no prediction information available.
     * It does *not* mean that the trip is progressing according to schedule.
     */
    public Builder trip(TripDescriptor trip) {
      this.trip = trip;
      return this;
    }

    /**
     * Additional information on the vehicle that is serving this trip.
     */
    public Builder vehicle(VehicleDescriptor vehicle) {
      this.vehicle = vehicle;
      return this;
    }

    /**
     * Updates to StopTimes for the trip (both future, i.e., predictions, and in
     * some cases, past ones, i.e., those that already happened).
     * The updates must be sorted by stop_sequence, and apply for all the
     * following stops of the trip up to the next specified one.
     *
     * Example 1:
     * For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure
     * delay of 0 for stop_sequence of the current stop means that the trip is
     * exactly on time.
     *
     * Example 2:
     * For the same trip instance, 3 StopTimeUpdates are provided:
     * - delay of 5 min for stop_sequence 3
     * - delay of 1 min for stop_sequence 8
     * - delay of unspecified duration for stop_sequence 10
     * This will be interpreted as:
     * - stop_sequences 3,4,5,6,7 have delay of 5 min.
     * - stop_sequences 8,9 have delay of 1 min.
     * - stop_sequences 10,... have unknown delay.
     */
    public Builder stop_time_update(List<StopTimeUpdate> stop_time_update) {
      Internal.checkElementsNotNull(stop_time_update);
      this.stop_time_update = stop_time_update;
      return this;
    }

    /**
     * Moment at which the vehicle's real-time progress was measured. In POSIX
     * time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC).
     */
    public Builder timestamp(Long timestamp) {
      this.timestamp = timestamp;
      return this;
    }

    /**
     * The current schedule deviation for the trip.  Delay should only be
     * specified when the prediction is given relative to some existing schedule
     * in GTFS.
     *
     * Delay (in seconds) can be positive (meaning that the vehicle is late) or
     * negative (meaning that the vehicle is ahead of schedule). Delay of 0
     * means that the vehicle is exactly on time.
     *
     * Delay information in StopTimeUpdates take precedent of trip-level delay
     * information, such that trip-level delay is only propagated until the next
     * stop along the trip with a StopTimeUpdate delay value specified.
     *
     * Feed providers are strongly encouraged to provide a TripUpdate.timestamp
     * value indicating when the delay value was last updated, in order to
     * evaluate the freshness of the data.
     *
     * NOTE: This field is still experimental, and subject to change. It may be
     * formally adopted in the future.
     */
    public Builder delay(Integer delay) {
      this.delay = delay;
      return this;
    }

    @Override
    public TripUpdate build() {
      if (trip == null) {
        throw Internal.missingRequiredFields(trip, "trip");
      }
      return new TripUpdate(trip, vehicle, stop_time_update, timestamp, delay, super.buildUnknownFields());
    }
  }

  /**
   * Timing information for a single predicted event (either arrival or
   * departure).
   * Timing consists of delay and/or estimated time, and uncertainty.
   * - delay should be used when the prediction is given relative to some
   *   existing schedule in GTFS.
   * - time should be given whether there is a predicted schedule or not. If
   *   both time and delay are specified, time will take precedence
   *   (although normally, time, if given for a scheduled trip, should be
   *   equal to scheduled time in GTFS + delay).
   *
   * Uncertainty applies equally to both time and delay.
   * The uncertainty roughly specifies the expected error in true delay (but
   * note, we don't yet define its precise statistical meaning). It's possible
   * for the uncertainty to be 0, for example for trains that are driven under
   * computer timing control.
   */
  public static final class StopTimeEvent extends Message<StopTimeEvent, StopTimeEvent.Builder> {
    public static final ProtoAdapter<StopTimeEvent> ADAPTER = new ProtoAdapter_StopTimeEvent();

    private static final long serialVersionUID = 0L;

    public static final Integer DEFAULT_DELAY = 0;

    public static final Long DEFAULT_TIME = 0L;

    public static final Integer DEFAULT_UNCERTAINTY = 0;

    /**
     * Delay (in seconds) can be positive (meaning that the vehicle is late) or
     * negative (meaning that the vehicle is ahead of schedule). Delay of 0
     * means that the vehicle is exactly on time.
     */
    @WireField(
        tag = 1,
        adapter = "com.squareup.wire.ProtoAdapter#INT32"
    )
    public final Integer delay;

    /**
     * Event as absolute time.
     * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
     * UTC).
     */
    @WireField(
        tag = 2,
        adapter = "com.squareup.wire.ProtoAdapter#INT64"
    )
    public final Long time;

    /**
     * If uncertainty is omitted, it is interpreted as unknown.
     * If the prediction is unknown or too uncertain, the delay (or time) field
     * should be empty. In such case, the uncertainty field is ignored.
     * To specify a completely certain prediction, set its uncertainty to 0.
     */
    @WireField(
        tag = 3,
        adapter = "com.squareup.wire.ProtoAdapter#INT32"
    )
    public final Integer uncertainty;

    public StopTimeEvent(Integer delay, Long time, Integer uncertainty) {
      this(delay, time, uncertainty, ByteString.EMPTY);
    }

    public StopTimeEvent(Integer delay, Long time, Integer uncertainty, ByteString unknownFields) {
      super(ADAPTER, unknownFields);
      this.delay = delay;
      this.time = time;
      this.uncertainty = uncertainty;
    }

    @Override
    public Builder newBuilder() {
      Builder builder = new Builder();
      builder.delay = delay;
      builder.time = time;
      builder.uncertainty = uncertainty;
      builder.addUnknownFields(unknownFields());
      return builder;
    }

    @Override
    public boolean equals(Object other) {
      if (other == this) return true;
      if (!(other instanceof StopTimeEvent)) return false;
      StopTimeEvent o = (StopTimeEvent) other;
      return unknownFields().equals(o.unknownFields())
          && Internal.equals(delay, o.delay)
          && Internal.equals(time, o.time)
          && Internal.equals(uncertainty, o.uncertainty);
    }

    @Override
    public int hashCode() {
      int result = super.hashCode;
      if (result == 0) {
        result = unknownFields().hashCode();
        result = result * 37 + (delay != null ? delay.hashCode() : 0);
        result = result * 37 + (time != null ? time.hashCode() : 0);
        result = result * 37 + (uncertainty != null ? uncertainty.hashCode() : 0);
        super.hashCode = result;
      }
      return result;
    }

    @Override
    public String toString() {
      StringBuilder builder = new StringBuilder();
      if (delay != null) builder.append(", delay=").append(delay);
      if (time != null) builder.append(", time=").append(time);
      if (uncertainty != null) builder.append(", uncertainty=").append(uncertainty);
      return builder.replace(0, 2, "StopTimeEvent{").append('}').toString();
    }

    public static final class Builder extends Message.Builder<StopTimeEvent, Builder> {
      public Integer delay;

      public Long time;

      public Integer uncertainty;

      public Builder() {
      }

      /**
       * Delay (in seconds) can be positive (meaning that the vehicle is late) or
       * negative (meaning that the vehicle is ahead of schedule). Delay of 0
       * means that the vehicle is exactly on time.
       */
      public Builder delay(Integer delay) {
        this.delay = delay;
        return this;
      }

      /**
       * Event as absolute time.
       * In Unix time (i.e., number of seconds since January 1st 1970 00:00:00
       * UTC).
       */
      public Builder time(Long time) {
        this.time = time;
        return this;
      }

      /**
       * If uncertainty is omitted, it is interpreted as unknown.
       * If the prediction is unknown or too uncertain, the delay (or time) field
       * should be empty. In such case, the uncertainty field is ignored.
       * To specify a completely certain prediction, set its uncertainty to 0.
       */
      public Builder uncertainty(Integer uncertainty) {
        this.uncertainty = uncertainty;
        return this;
      }

      @Override
      public StopTimeEvent build() {
        return new StopTimeEvent(delay, time, uncertainty, super.buildUnknownFields());
      }
    }

    private static final class ProtoAdapter_StopTimeEvent extends ProtoAdapter<StopTimeEvent> {
      public ProtoAdapter_StopTimeEvent() {
        super(FieldEncoding.LENGTH_DELIMITED, StopTimeEvent.class);
      }

      @Override
      public int encodedSize(StopTimeEvent value) {
        return ProtoAdapter.INT32.encodedSizeWithTag(1, value.delay)
            + ProtoAdapter.INT64.encodedSizeWithTag(2, value.time)
            + ProtoAdapter.INT32.encodedSizeWithTag(3, value.uncertainty)
            + value.unknownFields().size();
      }

      @Override
      public void encode(ProtoWriter writer, StopTimeEvent value) throws IOException {
        ProtoAdapter.INT32.encodeWithTag(writer, 1, value.delay);
        ProtoAdapter.INT64.encodeWithTag(writer, 2, value.time);
        ProtoAdapter.INT32.encodeWithTag(writer, 3, value.uncertainty);
        writer.writeBytes(value.unknownFields());
      }

      @Override
      public StopTimeEvent decode(ProtoReader reader) throws IOException {
        Builder builder = new Builder();
        long token = reader.beginMessage();
        for (int tag; (tag = reader.nextTag()) != -1;) {
          switch (tag) {
            case 1: builder.delay(ProtoAdapter.INT32.decode(reader)); break;
            case 2: builder.time(ProtoAdapter.INT64.decode(reader)); break;
            case 3: builder.uncertainty(ProtoAdapter.INT32.decode(reader)); break;
            default: {
              FieldEncoding fieldEncoding = reader.peekFieldEncoding();
              Object value = fieldEncoding.rawProtoAdapter().decode(reader);
              builder.addUnknownField(tag, fieldEncoding, value);
            }
          }
        }
        reader.endMessage(token);
        return builder.build();
      }

      @Override
      public StopTimeEvent redact(StopTimeEvent value) {
        Builder builder = value.newBuilder();
        builder.clearUnknownFields();
        return builder.build();
      }
    }
  }

  /**
   * Realtime update for arrival and/or departure events for a given stop on a
   * trip. Updates can be supplied for both past and future events.
   * The producer is allowed, although not required, to drop past events.
   */
  public static final class StopTimeUpdate extends Message<StopTimeUpdate, StopTimeUpdate.Builder> {
    public static final ProtoAdapter<StopTimeUpdate> ADAPTER = new ProtoAdapter_StopTimeUpdate();

    private static final long serialVersionUID = 0L;

    public static final Integer DEFAULT_STOP_SEQUENCE = 0;

    public static final String DEFAULT_STOP_ID = "";

    public static final ScheduleRelationship DEFAULT_SCHEDULE_RELATIONSHIP = ScheduleRelationship.SCHEDULED;

    /**
     * The update is linked to a specific stop either through stop_sequence or
     * stop_id, so one of the fields below must necessarily be set.
     * See the documentation in TripDescriptor for more information.
     * Must be the same as in stop_times.txt in the corresponding GTFS feed.
     */
    @WireField(
        tag = 1,
        adapter = "com.squareup.wire.ProtoAdapter#UINT32"
    )
    public final Integer stop_sequence;

    /**
     * Must be the same as in stops.txt in the corresponding GTFS feed.
     */
    @WireField(
        tag = 4,
        adapter = "com.squareup.wire.ProtoAdapter#STRING"
    )
    public final String stop_id;

    @WireField(
        tag = 2,
        adapter = "com.google.transit.realtime.TripUpdate$StopTimeEvent#ADAPTER"
    )
    public final StopTimeEvent arrival;

    @WireField(
        tag = 3,
        adapter = "com.google.transit.realtime.TripUpdate$StopTimeEvent#ADAPTER"
    )
    public final StopTimeEvent departure;

    @WireField(
        tag = 5,
        adapter = "com.google.transit.realtime.TripUpdate$StopTimeUpdate$ScheduleRelationship#ADAPTER"
    )
    public final ScheduleRelationship schedule_relationship;

    public StopTimeUpdate(Integer stop_sequence, String stop_id, StopTimeEvent arrival,
        StopTimeEvent departure, ScheduleRelationship schedule_relationship) {
      this(stop_sequence, stop_id, arrival, departure, schedule_relationship, ByteString.EMPTY);
    }

    public StopTimeUpdate(Integer stop_sequence, String stop_id, StopTimeEvent arrival,
        StopTimeEvent departure, ScheduleRelationship schedule_relationship,
        ByteString unknownFields) {
      super(ADAPTER, unknownFields);
      this.stop_sequence = stop_sequence;
      this.stop_id = stop_id;
      this.arrival = arrival;
      this.departure = departure;
      this.schedule_relationship = schedule_relationship;
    }

    @Override
    public Builder newBuilder() {
      Builder builder = new Builder();
      builder.stop_sequence = stop_sequence;
      builder.stop_id = stop_id;
      builder.arrival = arrival;
      builder.departure = departure;
      builder.schedule_relationship = schedule_relationship;
      builder.addUnknownFields(unknownFields());
      return builder;
    }

    @Override
    public boolean equals(Object other) {
      if (other == this) return true;
      if (!(other instanceof StopTimeUpdate)) return false;
      StopTimeUpdate o = (StopTimeUpdate) other;
      return unknownFields().equals(o.unknownFields())
          && Internal.equals(stop_sequence, o.stop_sequence)
          && Internal.equals(stop_id, o.stop_id)
          && Internal.equals(arrival, o.arrival)
          && Internal.equals(departure, o.departure)
          && Internal.equals(schedule_relationship, o.schedule_relationship);
    }

    @Override
    public int hashCode() {
      int result = super.hashCode;
      if (result == 0) {
        result = unknownFields().hashCode();
        result = result * 37 + (stop_sequence != null ? stop_sequence.hashCode() : 0);
        result = result * 37 + (stop_id != null ? stop_id.hashCode() : 0);
        result = result * 37 + (arrival != null ? arrival.hashCode() : 0);
        result = result * 37 + (departure != null ? departure.hashCode() : 0);
        result = result * 37 + (schedule_relationship != null ? schedule_relationship.hashCode() : 0);
        super.hashCode = result;
      }
      return result;
    }

    @Override
    public String toString() {
      StringBuilder builder = new StringBuilder();
      if (stop_sequence != null) builder.append(", stop_sequence=").append(stop_sequence);
      if (stop_id != null) builder.append(", stop_id=").append(stop_id);
      if (arrival != null) builder.append(", arrival=").append(arrival);
      if (departure != null) builder.append(", departure=").append(departure);
      if (schedule_relationship != null) builder.append(", schedule_relationship=").append(schedule_relationship);
      return builder.replace(0, 2, "StopTimeUpdate{").append('}').toString();
    }

    public static final class Builder extends Message.Builder<StopTimeUpdate, Builder> {
      public Integer stop_sequence;

      public String stop_id;

      public StopTimeEvent arrival;

      public StopTimeEvent departure;

      public ScheduleRelationship schedule_relationship;

      public Builder() {
      }

      /**
       * The update is linked to a specific stop either through stop_sequence or
       * stop_id, so one of the fields below must necessarily be set.
       * See the documentation in TripDescriptor for more information.
       * Must be the same as in stop_times.txt in the corresponding GTFS feed.
       */
      public Builder stop_sequence(Integer stop_sequence) {
        this.stop_sequence = stop_sequence;
        return this;
      }

      /**
       * Must be the same as in stops.txt in the corresponding GTFS feed.
       */
      public Builder stop_id(String stop_id) {
        this.stop_id = stop_id;
        return this;
      }

      public Builder arrival(StopTimeEvent arrival) {
        this.arrival = arrival;
        return this;
      }

      public Builder departure(StopTimeEvent departure) {
        this.departure = departure;
        return this;
      }

      public Builder schedule_relationship(ScheduleRelationship schedule_relationship) {
        this.schedule_relationship = schedule_relationship;
        return this;
      }

      @Override
      public StopTimeUpdate build() {
        return new StopTimeUpdate(stop_sequence, stop_id, arrival, departure, schedule_relationship, super.buildUnknownFields());
      }
    }

    /**
     * The relation between this StopTime and the static schedule.
     */
    public enum ScheduleRelationship implements WireEnum {
      /**
       * The vehicle is proceeding in accordance with its static schedule of
       * stops, although not necessarily according to the times of the schedule.
       * At least one of arrival and departure must be provided. If the schedule
       * for this stop contains both arrival and departure times then so must
       * this update.
       */
      SCHEDULED(0),

      /**
       * The stop is skipped, i.e., the vehicle will not stop at this stop.
       * Arrival and departure are optional.
       */
      SKIPPED(1),

      /**
       * No data is given for this stop. The main intention for this value is to
       * give the predictions only for part of a trip, i.e., if the last update
       * for a trip has a NO_DATA specifier, then StopTimes for the rest of the
       * stops in the trip are considered to be unspecified as well.
       * Neither arrival nor departure should be supplied.
       */
      NO_DATA(2);

      public static final ProtoAdapter<ScheduleRelationship> ADAPTER = new ProtoAdapter_ScheduleRelationship();

      private final int value;

      ScheduleRelationship(int value) {
        this.value = value;
      }

      /**
       * Return the constant for {@code value} or null.
       */
      public static ScheduleRelationship fromValue(int value) {
        switch (value) {
          case 0: return SCHEDULED;
          case 1: return SKIPPED;
          case 2: return NO_DATA;
          default: return null;
        }
      }

      @Override
      public int getValue() {
        return value;
      }

      private static final class ProtoAdapter_ScheduleRelationship extends EnumAdapter<ScheduleRelationship> {
        ProtoAdapter_ScheduleRelationship() {
          super(ScheduleRelationship.class);
        }

        @Override
        protected ScheduleRelationship fromValue(int value) {
          return ScheduleRelationship.fromValue(value);
        }
      }
    }

    private static final class ProtoAdapter_StopTimeUpdate extends ProtoAdapter<StopTimeUpdate> {
      public ProtoAdapter_StopTimeUpdate() {
        super(FieldEncoding.LENGTH_DELIMITED, StopTimeUpdate.class);
      }

      @Override
      public int encodedSize(StopTimeUpdate value) {
        return ProtoAdapter.UINT32.encodedSizeWithTag(1, value.stop_sequence)
            + ProtoAdapter.STRING.encodedSizeWithTag(4, value.stop_id)
            + StopTimeEvent.ADAPTER.encodedSizeWithTag(2, value.arrival)
            + StopTimeEvent.ADAPTER.encodedSizeWithTag(3, value.departure)
            + ScheduleRelationship.ADAPTER.encodedSizeWithTag(5, value.schedule_relationship)
            + value.unknownFields().size();
      }

      @Override
      public void encode(ProtoWriter writer, StopTimeUpdate value) throws IOException {
        ProtoAdapter.UINT32.encodeWithTag(writer, 1, value.stop_sequence);
        ProtoAdapter.STRING.encodeWithTag(writer, 4, value.stop_id);
        StopTimeEvent.ADAPTER.encodeWithTag(writer, 2, value.arrival);
        StopTimeEvent.ADAPTER.encodeWithTag(writer, 3, value.departure);
        ScheduleRelationship.ADAPTER.encodeWithTag(writer, 5, value.schedule_relationship);
        writer.writeBytes(value.unknownFields());
      }

      @Override
      public StopTimeUpdate decode(ProtoReader reader) throws IOException {
        Builder builder = new Builder();
        long token = reader.beginMessage();
        for (int tag; (tag = reader.nextTag()) != -1;) {
          switch (tag) {
            case 1: builder.stop_sequence(ProtoAdapter.UINT32.decode(reader)); break;
            case 2: builder.arrival(StopTimeEvent.ADAPTER.decode(reader)); break;
            case 3: builder.departure(StopTimeEvent.ADAPTER.decode(reader)); break;
            case 4: builder.stop_id(ProtoAdapter.STRING.decode(reader)); break;
            case 5: {
              try {
                builder.schedule_relationship(ScheduleRelationship.ADAPTER.decode(reader));
              } catch (ProtoAdapter.EnumConstantNotFoundException e) {
                builder.addUnknownField(tag, FieldEncoding.VARINT, (long) e.value);
              }
              break;
            }
            default: {
              FieldEncoding fieldEncoding = reader.peekFieldEncoding();
              Object value = fieldEncoding.rawProtoAdapter().decode(reader);
              builder.addUnknownField(tag, fieldEncoding, value);
            }
          }
        }
        reader.endMessage(token);
        return builder.build();
      }

      @Override
      public StopTimeUpdate redact(StopTimeUpdate value) {
        Builder builder = value.newBuilder();
        if (builder.arrival != null) builder.arrival = StopTimeEvent.ADAPTER.redact(builder.arrival);
        if (builder.departure != null) builder.departure = StopTimeEvent.ADAPTER.redact(builder.departure);
        builder.clearUnknownFields();
        return builder.build();
      }
    }
  }

  private static final class ProtoAdapter_TripUpdate extends ProtoAdapter<TripUpdate> {
    public ProtoAdapter_TripUpdate() {
      super(FieldEncoding.LENGTH_DELIMITED, TripUpdate.class);
    }

    @Override
    public int encodedSize(TripUpdate value) {
      return TripDescriptor.ADAPTER.encodedSizeWithTag(1, value.trip)
          + VehicleDescriptor.ADAPTER.encodedSizeWithTag(3, value.vehicle)
          + StopTimeUpdate.ADAPTER.asRepeated().encodedSizeWithTag(2, value.stop_time_update)
          + ProtoAdapter.UINT64.encodedSizeWithTag(4, value.timestamp)
          + ProtoAdapter.INT32.encodedSizeWithTag(5, value.delay)
          + value.unknownFields().size();
    }

    @Override
    public void encode(ProtoWriter writer, TripUpdate value) throws IOException {
      TripDescriptor.ADAPTER.encodeWithTag(writer, 1, value.trip);
      VehicleDescriptor.ADAPTER.encodeWithTag(writer, 3, value.vehicle);
      StopTimeUpdate.ADAPTER.asRepeated().encodeWithTag(writer, 2, value.stop_time_update);
      ProtoAdapter.UINT64.encodeWithTag(writer, 4, value.timestamp);
      ProtoAdapter.INT32.encodeWithTag(writer, 5, value.delay);
      writer.writeBytes(value.unknownFields());
    }

    @Override
    public TripUpdate decode(ProtoReader reader) throws IOException {
      Builder builder = new Builder();
      long token = reader.beginMessage();
      for (int tag; (tag = reader.nextTag()) != -1;) {
        switch (tag) {
          case 1: builder.trip(TripDescriptor.ADAPTER.decode(reader)); break;
          case 2: builder.stop_time_update.add(StopTimeUpdate.ADAPTER.decode(reader)); break;
          case 3: builder.vehicle(VehicleDescriptor.ADAPTER.decode(reader)); break;
          case 4: builder.timestamp(ProtoAdapter.UINT64.decode(reader)); break;
          case 5: builder.delay(ProtoAdapter.INT32.decode(reader)); break;
          default: {
            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
            builder.addUnknownField(tag, fieldEncoding, value);
          }
        }
      }
      reader.endMessage(token);
      return builder.build();
    }

    @Override
    public TripUpdate redact(TripUpdate value) {
      Builder builder = value.newBuilder();
      builder.trip = TripDescriptor.ADAPTER.redact(builder.trip);
      if (builder.vehicle != null) builder.vehicle = VehicleDescriptor.ADAPTER.redact(builder.vehicle);
      Internal.redactElements(builder.stop_time_update, StopTimeUpdate.ADAPTER);
      builder.clearUnknownFields();
      return builder.build();
    }
  }
}
