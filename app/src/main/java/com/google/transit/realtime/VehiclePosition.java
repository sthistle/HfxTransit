// Code generated by Wire protocol buffer compiler, do not edit.
// Source file: gtfs-realtime.proto
package com.google.transit.realtime;

import com.squareup.wire.EnumAdapter;
import com.squareup.wire.FieldEncoding;
import com.squareup.wire.Message;
import com.squareup.wire.ProtoAdapter;
import com.squareup.wire.ProtoReader;
import com.squareup.wire.ProtoWriter;
import com.squareup.wire.WireEnum;
import com.squareup.wire.WireField;
import com.squareup.wire.internal.Internal;
import java.io.IOException;
import java.lang.Integer;
import java.lang.Long;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import okio.ByteString;

/**
 * Realtime positioning information for a given vehicle.
 */
public final class VehiclePosition extends Message<VehiclePosition, VehiclePosition.Builder> {
  public static final ProtoAdapter<VehiclePosition> ADAPTER = new ProtoAdapter_VehiclePosition();

  private static final long serialVersionUID = 0L;

  public static final Integer DEFAULT_CURRENT_STOP_SEQUENCE = 0;

  public static final String DEFAULT_STOP_ID = "";

  public static final VehicleStopStatus DEFAULT_CURRENT_STATUS = VehicleStopStatus.IN_TRANSIT_TO;

  public static final Long DEFAULT_TIMESTAMP = 0L;

  public static final CongestionLevel DEFAULT_CONGESTION_LEVEL = CongestionLevel.UNKNOWN_CONGESTION_LEVEL;

  public static final OccupancyStatus DEFAULT_OCCUPANCY_STATUS = OccupancyStatus.EMPTY;

  /**
   * The Trip that this vehicle is serving.
   * Can be empty or partial if the vehicle can not be identified with a given
   * trip instance.
   */
  @WireField(
      tag = 1,
      adapter = "com.google.transit.realtime.TripDescriptor#ADAPTER"
  )
  public final TripDescriptor trip;

  /**
   * Additional information on the vehicle that is serving this trip.
   */
  @WireField(
      tag = 8,
      adapter = "com.google.transit.realtime.VehicleDescriptor#ADAPTER"
  )
  public final VehicleDescriptor vehicle;

  /**
   * Current position of this vehicle.
   */
  @WireField(
      tag = 2,
      adapter = "com.google.transit.realtime.Position#ADAPTER"
  )
  public final Position position;

  /**
   * The stop sequence index of the current stop. The meaning of
   * current_stop_sequence (i.e., the stop that it refers to) is determined by
   * current_status.
   * If current_status is missing IN_TRANSIT_TO is assumed.
   */
  @WireField(
      tag = 3,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32"
  )
  public final Integer current_stop_sequence;

  /**
   * Identifies the current stop. The value must be the same as in stops.txt in
   * the corresponding GTFS feed.
   */
  @WireField(
      tag = 7,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  public final String stop_id;

  /**
   * The exact status of the vehicle with respect to the current stop.
   * Ignored if current_stop_sequence is missing.
   */
  @WireField(
      tag = 4,
      adapter = "com.google.transit.realtime.VehiclePosition$VehicleStopStatus#ADAPTER"
  )
  public final VehicleStopStatus current_status;

  /**
   * Moment at which the vehicle's position was measured. In POSIX time
   * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
   */
  @WireField(
      tag = 5,
      adapter = "com.squareup.wire.ProtoAdapter#UINT64"
  )
  public final Long timestamp;

  @WireField(
      tag = 6,
      adapter = "com.google.transit.realtime.VehiclePosition$CongestionLevel#ADAPTER"
  )
  public final CongestionLevel congestion_level;

  @WireField(
      tag = 9,
      adapter = "com.google.transit.realtime.VehiclePosition$OccupancyStatus#ADAPTER"
  )
  public final OccupancyStatus occupancy_status;

  public VehiclePosition(TripDescriptor trip, VehicleDescriptor vehicle, Position position,
      Integer current_stop_sequence, String stop_id, VehicleStopStatus current_status,
      Long timestamp, CongestionLevel congestion_level, OccupancyStatus occupancy_status) {
    this(trip, vehicle, position, current_stop_sequence, stop_id, current_status, timestamp, congestion_level, occupancy_status, ByteString.EMPTY);
  }

  public VehiclePosition(TripDescriptor trip, VehicleDescriptor vehicle, Position position,
      Integer current_stop_sequence, String stop_id, VehicleStopStatus current_status,
      Long timestamp, CongestionLevel congestion_level, OccupancyStatus occupancy_status,
      ByteString unknownFields) {
    super(ADAPTER, unknownFields);
    this.trip = trip;
    this.vehicle = vehicle;
    this.position = position;
    this.current_stop_sequence = current_stop_sequence;
    this.stop_id = stop_id;
    this.current_status = current_status;
    this.timestamp = timestamp;
    this.congestion_level = congestion_level;
    this.occupancy_status = occupancy_status;
  }

  @Override
  public Builder newBuilder() {
    Builder builder = new Builder();
    builder.trip = trip;
    builder.vehicle = vehicle;
    builder.position = position;
    builder.current_stop_sequence = current_stop_sequence;
    builder.stop_id = stop_id;
    builder.current_status = current_status;
    builder.timestamp = timestamp;
    builder.congestion_level = congestion_level;
    builder.occupancy_status = occupancy_status;
    builder.addUnknownFields(unknownFields());
    return builder;
  }

  @Override
  public boolean equals(Object other) {
    if (other == this) return true;
    if (!(other instanceof VehiclePosition)) return false;
    VehiclePosition o = (VehiclePosition) other;
    return unknownFields().equals(o.unknownFields())
        && Internal.equals(trip, o.trip)
        && Internal.equals(vehicle, o.vehicle)
        && Internal.equals(position, o.position)
        && Internal.equals(current_stop_sequence, o.current_stop_sequence)
        && Internal.equals(stop_id, o.stop_id)
        && Internal.equals(current_status, o.current_status)
        && Internal.equals(timestamp, o.timestamp)
        && Internal.equals(congestion_level, o.congestion_level)
        && Internal.equals(occupancy_status, o.occupancy_status);
  }

  @Override
  public int hashCode() {
    int result = super.hashCode;
    if (result == 0) {
      result = unknownFields().hashCode();
      result = result * 37 + (trip != null ? trip.hashCode() : 0);
      result = result * 37 + (vehicle != null ? vehicle.hashCode() : 0);
      result = result * 37 + (position != null ? position.hashCode() : 0);
      result = result * 37 + (current_stop_sequence != null ? current_stop_sequence.hashCode() : 0);
      result = result * 37 + (stop_id != null ? stop_id.hashCode() : 0);
      result = result * 37 + (current_status != null ? current_status.hashCode() : 0);
      result = result * 37 + (timestamp != null ? timestamp.hashCode() : 0);
      result = result * 37 + (congestion_level != null ? congestion_level.hashCode() : 0);
      result = result * 37 + (occupancy_status != null ? occupancy_status.hashCode() : 0);
      super.hashCode = result;
    }
    return result;
  }

  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    if (trip != null) builder.append(", trip=").append(trip);
    if (vehicle != null) builder.append(", vehicle=").append(vehicle);
    if (position != null) builder.append(", position=").append(position);
    if (current_stop_sequence != null) builder.append(", current_stop_sequence=").append(current_stop_sequence);
    if (stop_id != null) builder.append(", stop_id=").append(stop_id);
    if (current_status != null) builder.append(", current_status=").append(current_status);
    if (timestamp != null) builder.append(", timestamp=").append(timestamp);
    if (congestion_level != null) builder.append(", congestion_level=").append(congestion_level);
    if (occupancy_status != null) builder.append(", occupancy_status=").append(occupancy_status);
    return builder.replace(0, 2, "VehiclePosition{").append('}').toString();
  }

  public static final class Builder extends Message.Builder<VehiclePosition, Builder> {
    public TripDescriptor trip;

    public VehicleDescriptor vehicle;

    public Position position;

    public Integer current_stop_sequence;

    public String stop_id;

    public VehicleStopStatus current_status;

    public Long timestamp;

    public CongestionLevel congestion_level;

    public OccupancyStatus occupancy_status;

    public Builder() {
    }

    /**
     * The Trip that this vehicle is serving.
     * Can be empty or partial if the vehicle can not be identified with a given
     * trip instance.
     */
    public Builder trip(TripDescriptor trip) {
      this.trip = trip;
      return this;
    }

    /**
     * Additional information on the vehicle that is serving this trip.
     */
    public Builder vehicle(VehicleDescriptor vehicle) {
      this.vehicle = vehicle;
      return this;
    }

    /**
     * Current position of this vehicle.
     */
    public Builder position(Position position) {
      this.position = position;
      return this;
    }

    /**
     * The stop sequence index of the current stop. The meaning of
     * current_stop_sequence (i.e., the stop that it refers to) is determined by
     * current_status.
     * If current_status is missing IN_TRANSIT_TO is assumed.
     */
    public Builder current_stop_sequence(Integer current_stop_sequence) {
      this.current_stop_sequence = current_stop_sequence;
      return this;
    }

    /**
     * Identifies the current stop. The value must be the same as in stops.txt in
     * the corresponding GTFS feed.
     */
    public Builder stop_id(String stop_id) {
      this.stop_id = stop_id;
      return this;
    }

    /**
     * The exact status of the vehicle with respect to the current stop.
     * Ignored if current_stop_sequence is missing.
     */
    public Builder current_status(VehicleStopStatus current_status) {
      this.current_status = current_status;
      return this;
    }

    /**
     * Moment at which the vehicle's position was measured. In POSIX time
     * (i.e., number of seconds since January 1st 1970 00:00:00 UTC).
     */
    public Builder timestamp(Long timestamp) {
      this.timestamp = timestamp;
      return this;
    }

    public Builder congestion_level(CongestionLevel congestion_level) {
      this.congestion_level = congestion_level;
      return this;
    }

    public Builder occupancy_status(OccupancyStatus occupancy_status) {
      this.occupancy_status = occupancy_status;
      return this;
    }

    @Override
    public VehiclePosition build() {
      return new VehiclePosition(trip, vehicle, position, current_stop_sequence, stop_id, current_status, timestamp, congestion_level, occupancy_status, super.buildUnknownFields());
    }
  }

  public enum VehicleStopStatus implements WireEnum {
    /**
     * The vehicle is just about to arrive at the stop (on a stop
     * display, the vehicle symbol typically flashes).
     */
    INCOMING_AT(0),

    /**
     * The vehicle is standing at the stop.
     */
    STOPPED_AT(1),

    /**
     * The vehicle has departed and is in transit to the next stop.
     */
    IN_TRANSIT_TO(2);

    public static final ProtoAdapter<VehicleStopStatus> ADAPTER = new ProtoAdapter_VehicleStopStatus();

    private final int value;

    VehicleStopStatus(int value) {
      this.value = value;
    }

    /**
     * Return the constant for {@code value} or null.
     */
    public static VehicleStopStatus fromValue(int value) {
      switch (value) {
        case 0: return INCOMING_AT;
        case 1: return STOPPED_AT;
        case 2: return IN_TRANSIT_TO;
        default: return null;
      }
    }

    @Override
    public int getValue() {
      return value;
    }

    private static final class ProtoAdapter_VehicleStopStatus extends EnumAdapter<VehicleStopStatus> {
      ProtoAdapter_VehicleStopStatus() {
        super(VehicleStopStatus.class);
      }

      @Override
      protected VehicleStopStatus fromValue(int value) {
        return VehicleStopStatus.fromValue(value);
      }
    }
  }

  /**
   * Congestion level that is affecting this vehicle.
   */
  public enum CongestionLevel implements WireEnum {
    UNKNOWN_CONGESTION_LEVEL(0),

    RUNNING_SMOOTHLY(1),

    STOP_AND_GO(2),

    CONGESTION(3),

    /**
     * People leaving their cars.
     */
    SEVERE_CONGESTION(4);

    public static final ProtoAdapter<CongestionLevel> ADAPTER = new ProtoAdapter_CongestionLevel();

    private final int value;

    CongestionLevel(int value) {
      this.value = value;
    }

    /**
     * Return the constant for {@code value} or null.
     */
    public static CongestionLevel fromValue(int value) {
      switch (value) {
        case 0: return UNKNOWN_CONGESTION_LEVEL;
        case 1: return RUNNING_SMOOTHLY;
        case 2: return STOP_AND_GO;
        case 3: return CONGESTION;
        case 4: return SEVERE_CONGESTION;
        default: return null;
      }
    }

    @Override
    public int getValue() {
      return value;
    }

    private static final class ProtoAdapter_CongestionLevel extends EnumAdapter<CongestionLevel> {
      ProtoAdapter_CongestionLevel() {
        super(CongestionLevel.class);
      }

      @Override
      protected CongestionLevel fromValue(int value) {
        return CongestionLevel.fromValue(value);
      }
    }
  }

  /**
   * The degree of passenger occupancy of the vehicle. This field is still
   * experimental, and subject to change. It may be formally adopted in the
   * future.
   */
  public enum OccupancyStatus implements WireEnum {
    /**
     * The vehicle is considered empty by most measures, and has few or no
     * passengers onboard, but is still accepting passengers.
     */
    EMPTY(0),

    /**
     * The vehicle has a relatively large percentage of seats available.
     * What percentage of free seats out of the total seats available is to be
     * considered large enough to fall into this category is determined at the
     * discretion of the producer.
     */
    MANY_SEATS_AVAILABLE(1),

    /**
     * The vehicle has a relatively small percentage of seats available.
     * What percentage of free seats out of the total seats available is to be
     * considered small enough to fall into this category is determined at the
     * discretion of the feed producer.
     */
    FEW_SEATS_AVAILABLE(2),

    /**
     * The vehicle can currently accommodate only standing passengers.
     */
    STANDING_ROOM_ONLY(3),

    /**
     * The vehicle can currently accommodate only standing passengers
     * and has limited space for them.
     */
    CRUSHED_STANDING_ROOM_ONLY(4),

    /**
     * The vehicle is considered full by most measures, but may still be
     * allowing passengers to board.
     */
    FULL(5),

    /**
     * The vehicle is not accepting additional passengers.
     */
    NOT_ACCEPTING_PASSENGERS(6);

    public static final ProtoAdapter<OccupancyStatus> ADAPTER = new ProtoAdapter_OccupancyStatus();

    private final int value;

    OccupancyStatus(int value) {
      this.value = value;
    }

    /**
     * Return the constant for {@code value} or null.
     */
    public static OccupancyStatus fromValue(int value) {
      switch (value) {
        case 0: return EMPTY;
        case 1: return MANY_SEATS_AVAILABLE;
        case 2: return FEW_SEATS_AVAILABLE;
        case 3: return STANDING_ROOM_ONLY;
        case 4: return CRUSHED_STANDING_ROOM_ONLY;
        case 5: return FULL;
        case 6: return NOT_ACCEPTING_PASSENGERS;
        default: return null;
      }
    }

    @Override
    public int getValue() {
      return value;
    }

    private static final class ProtoAdapter_OccupancyStatus extends EnumAdapter<OccupancyStatus> {
      ProtoAdapter_OccupancyStatus() {
        super(OccupancyStatus.class);
      }

      @Override
      protected OccupancyStatus fromValue(int value) {
        return OccupancyStatus.fromValue(value);
      }
    }
  }

  private static final class ProtoAdapter_VehiclePosition extends ProtoAdapter<VehiclePosition> {
    public ProtoAdapter_VehiclePosition() {
      super(FieldEncoding.LENGTH_DELIMITED, VehiclePosition.class);
    }

    @Override
    public int encodedSize(VehiclePosition value) {
      return TripDescriptor.ADAPTER.encodedSizeWithTag(1, value.trip)
          + VehicleDescriptor.ADAPTER.encodedSizeWithTag(8, value.vehicle)
          + Position.ADAPTER.encodedSizeWithTag(2, value.position)
          + ProtoAdapter.UINT32.encodedSizeWithTag(3, value.current_stop_sequence)
          + ProtoAdapter.STRING.encodedSizeWithTag(7, value.stop_id)
          + VehicleStopStatus.ADAPTER.encodedSizeWithTag(4, value.current_status)
          + ProtoAdapter.UINT64.encodedSizeWithTag(5, value.timestamp)
          + CongestionLevel.ADAPTER.encodedSizeWithTag(6, value.congestion_level)
          + OccupancyStatus.ADAPTER.encodedSizeWithTag(9, value.occupancy_status)
          + value.unknownFields().size();
    }

    @Override
    public void encode(ProtoWriter writer, VehiclePosition value) throws IOException {
      TripDescriptor.ADAPTER.encodeWithTag(writer, 1, value.trip);
      VehicleDescriptor.ADAPTER.encodeWithTag(writer, 8, value.vehicle);
      Position.ADAPTER.encodeWithTag(writer, 2, value.position);
      ProtoAdapter.UINT32.encodeWithTag(writer, 3, value.current_stop_sequence);
      ProtoAdapter.STRING.encodeWithTag(writer, 7, value.stop_id);
      VehicleStopStatus.ADAPTER.encodeWithTag(writer, 4, value.current_status);
      ProtoAdapter.UINT64.encodeWithTag(writer, 5, value.timestamp);
      CongestionLevel.ADAPTER.encodeWithTag(writer, 6, value.congestion_level);
      OccupancyStatus.ADAPTER.encodeWithTag(writer, 9, value.occupancy_status);
      writer.writeBytes(value.unknownFields());
    }

    @Override
    public VehiclePosition decode(ProtoReader reader) throws IOException {
      Builder builder = new Builder();
      long token = reader.beginMessage();
      for (int tag; (tag = reader.nextTag()) != -1;) {
        switch (tag) {
          case 1: builder.trip(TripDescriptor.ADAPTER.decode(reader)); break;
          case 2: builder.position(Position.ADAPTER.decode(reader)); break;
          case 3: builder.current_stop_sequence(ProtoAdapter.UINT32.decode(reader)); break;
          case 4: {
            try {
              builder.current_status(VehicleStopStatus.ADAPTER.decode(reader));
            } catch (ProtoAdapter.EnumConstantNotFoundException e) {
              builder.addUnknownField(tag, FieldEncoding.VARINT, (long) e.value);
            }
            break;
          }
          case 5: builder.timestamp(ProtoAdapter.UINT64.decode(reader)); break;
          case 6: {
            try {
              builder.congestion_level(CongestionLevel.ADAPTER.decode(reader));
            } catch (ProtoAdapter.EnumConstantNotFoundException e) {
              builder.addUnknownField(tag, FieldEncoding.VARINT, (long) e.value);
            }
            break;
          }
          case 7: builder.stop_id(ProtoAdapter.STRING.decode(reader)); break;
          case 8: builder.vehicle(VehicleDescriptor.ADAPTER.decode(reader)); break;
          case 9: {
            try {
              builder.occupancy_status(OccupancyStatus.ADAPTER.decode(reader));
            } catch (ProtoAdapter.EnumConstantNotFoundException e) {
              builder.addUnknownField(tag, FieldEncoding.VARINT, (long) e.value);
            }
            break;
          }
          default: {
            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
            builder.addUnknownField(tag, fieldEncoding, value);
          }
        }
      }
      reader.endMessage(token);
      return builder.build();
    }

    @Override
    public VehiclePosition redact(VehiclePosition value) {
      Builder builder = value.newBuilder();
      if (builder.trip != null) builder.trip = TripDescriptor.ADAPTER.redact(builder.trip);
      if (builder.vehicle != null) builder.vehicle = VehicleDescriptor.ADAPTER.redact(builder.vehicle);
      if (builder.position != null) builder.position = Position.ADAPTER.redact(builder.position);
      builder.clearUnknownFields();
      return builder.build();
    }
  }
}
