// Code generated by Wire protocol buffer compiler, do not edit.
// Source file: gtfs-realtime.proto
package com.google.transit.realtime;

import com.squareup.wire.EnumAdapter;
import com.squareup.wire.FieldEncoding;
import com.squareup.wire.Message;
import com.squareup.wire.ProtoAdapter;
import com.squareup.wire.ProtoReader;
import com.squareup.wire.ProtoWriter;
import com.squareup.wire.WireEnum;
import com.squareup.wire.WireField;
import com.squareup.wire.internal.Internal;
import java.io.IOException;
import java.lang.Integer;
import java.lang.Object;
import java.lang.Override;
import java.lang.String;
import java.lang.StringBuilder;
import okio.ByteString;

/**
 * A descriptor that identifies an instance of a GTFS trip, or all instances of
 * a trip along a route.
 * - To specify a single trip instance, the trip_id (and if necessary,
 *   start_time) is set. If route_id is also set, then it should be same as one
 *   that the given trip corresponds to.
 * - To specify all the trips along a given route, only the route_id should be
 *   set. Note that if the trip_id is not known, then stop sequence ids in
 *   TripUpdate are not sufficient, and stop_ids must be provided as well. In
 *   addition, absolute arrival/departure times must be provided.
 */
public final class TripDescriptor extends Message<TripDescriptor, TripDescriptor.Builder> {
  public static final ProtoAdapter<TripDescriptor> ADAPTER = new ProtoAdapter_TripDescriptor();

  private static final long serialVersionUID = 0L;

  public static final String DEFAULT_TRIP_ID = "";

  public static final String DEFAULT_ROUTE_ID = "";

  public static final Integer DEFAULT_DIRECTION_ID = 0;

  public static final String DEFAULT_START_TIME = "";

  public static final String DEFAULT_START_DATE = "";

  public static final ScheduleRelationship DEFAULT_SCHEDULE_RELATIONSHIP = ScheduleRelationship.SCHEDULED;

  /**
   * The trip_id from the GTFS feed that this selector refers to.
   * For non frequency-based trips, this field is enough to uniquely identify
   * the trip. For frequency-based trip, start_time and start_date might also be
   * necessary.
   */
  @WireField(
      tag = 1,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  public final String trip_id;

  /**
   * The route_id from the GTFS that this selector refers to.
   */
  @WireField(
      tag = 5,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  public final String route_id;

  /**
   * The direction_id from the GTFS feed trips.txt file, indicating the
   * direction of travel for trips this selector refers to. This field is
   * still experimental, and subject to change. It may be formally adopted in
   * the future.
   */
  @WireField(
      tag = 6,
      adapter = "com.squareup.wire.ProtoAdapter#UINT32"
  )
  public final Integer direction_id;

  /**
   * The initially scheduled start time of this trip instance.
   * When the trip_id corresponds to a non-frequency-based trip, this field
   * should either be omitted or be equal to the value in the GTFS feed. When
   * the trip_id correponds to a frequency-based trip, the start_time must be
   * specified for trip updates and vehicle positions. If the trip corresponds
   * to exact_times=1 GTFS record, then start_time must be some multiple
   * (including zero) of headway_secs later than frequencies.txt start_time for
   * the corresponding time period. If the trip corresponds to exact_times=0,
   * then its start_time may be arbitrary, and is initially expected to be the
   * first departure of the trip. Once established, the start_time of this
   * frequency-based trip should be considered immutable, even if the first
   * departure time changes -- that time change may instead be reflected in a
   * StopTimeUpdate.
   * Format and semantics of the field is same as that of
   * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
   */
  @WireField(
      tag = 2,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  public final String start_time;

  /**
   * The scheduled start date of this trip instance.
   * Must be provided to disambiguate trips that are so late as to collide with
   * a scheduled trip on a next day. For example, for a train that departs 8:00
   * and 20:00 every day, and is 12 hours late, there would be two distinct
   * trips on the same time.
   * This field can be provided but is not mandatory for schedules in which such
   * collisions are impossible - for example, a service running on hourly
   * schedule where a vehicle that is one hour late is not considered to be
   * related to schedule anymore.
   * In YYYYMMDD format.
   */
  @WireField(
      tag = 3,
      adapter = "com.squareup.wire.ProtoAdapter#STRING"
  )
  public final String start_date;

  @WireField(
      tag = 4,
      adapter = "com.google.transit.realtime.TripDescriptor$ScheduleRelationship#ADAPTER"
  )
  public final ScheduleRelationship schedule_relationship;

  public TripDescriptor(String trip_id, String route_id, Integer direction_id, String start_time,
      String start_date, ScheduleRelationship schedule_relationship) {
    this(trip_id, route_id, direction_id, start_time, start_date, schedule_relationship, ByteString.EMPTY);
  }

  public TripDescriptor(String trip_id, String route_id, Integer direction_id, String start_time,
      String start_date, ScheduleRelationship schedule_relationship, ByteString unknownFields) {
    super(ADAPTER, unknownFields);
    this.trip_id = trip_id;
    this.route_id = route_id;
    this.direction_id = direction_id;
    this.start_time = start_time;
    this.start_date = start_date;
    this.schedule_relationship = schedule_relationship;
  }

  @Override
  public Builder newBuilder() {
    Builder builder = new Builder();
    builder.trip_id = trip_id;
    builder.route_id = route_id;
    builder.direction_id = direction_id;
    builder.start_time = start_time;
    builder.start_date = start_date;
    builder.schedule_relationship = schedule_relationship;
    builder.addUnknownFields(unknownFields());
    return builder;
  }

  @Override
  public boolean equals(Object other) {
    if (other == this) return true;
    if (!(other instanceof TripDescriptor)) return false;
    TripDescriptor o = (TripDescriptor) other;
    return unknownFields().equals(o.unknownFields())
        && Internal.equals(trip_id, o.trip_id)
        && Internal.equals(route_id, o.route_id)
        && Internal.equals(direction_id, o.direction_id)
        && Internal.equals(start_time, o.start_time)
        && Internal.equals(start_date, o.start_date)
        && Internal.equals(schedule_relationship, o.schedule_relationship);
  }

  @Override
  public int hashCode() {
    int result = super.hashCode;
    if (result == 0) {
      result = unknownFields().hashCode();
      result = result * 37 + (trip_id != null ? trip_id.hashCode() : 0);
      result = result * 37 + (route_id != null ? route_id.hashCode() : 0);
      result = result * 37 + (direction_id != null ? direction_id.hashCode() : 0);
      result = result * 37 + (start_time != null ? start_time.hashCode() : 0);
      result = result * 37 + (start_date != null ? start_date.hashCode() : 0);
      result = result * 37 + (schedule_relationship != null ? schedule_relationship.hashCode() : 0);
      super.hashCode = result;
    }
    return result;
  }

  @Override
  public String toString() {
    StringBuilder builder = new StringBuilder();
    if (trip_id != null) builder.append(", trip_id=").append(trip_id);
    if (route_id != null) builder.append(", route_id=").append(route_id);
    if (direction_id != null) builder.append(", direction_id=").append(direction_id);
    if (start_time != null) builder.append(", start_time=").append(start_time);
    if (start_date != null) builder.append(", start_date=").append(start_date);
    if (schedule_relationship != null) builder.append(", schedule_relationship=").append(schedule_relationship);
    return builder.replace(0, 2, "TripDescriptor{").append('}').toString();
  }

  public static final class Builder extends Message.Builder<TripDescriptor, Builder> {
    public String trip_id;

    public String route_id;

    public Integer direction_id;

    public String start_time;

    public String start_date;

    public ScheduleRelationship schedule_relationship;

    public Builder() {
    }

    /**
     * The trip_id from the GTFS feed that this selector refers to.
     * For non frequency-based trips, this field is enough to uniquely identify
     * the trip. For frequency-based trip, start_time and start_date might also be
     * necessary.
     */
    public Builder trip_id(String trip_id) {
      this.trip_id = trip_id;
      return this;
    }

    /**
     * The route_id from the GTFS that this selector refers to.
     */
    public Builder route_id(String route_id) {
      this.route_id = route_id;
      return this;
    }

    /**
     * The direction_id from the GTFS feed trips.txt file, indicating the
     * direction of travel for trips this selector refers to. This field is
     * still experimental, and subject to change. It may be formally adopted in
     * the future.
     */
    public Builder direction_id(Integer direction_id) {
      this.direction_id = direction_id;
      return this;
    }

    /**
     * The initially scheduled start time of this trip instance.
     * When the trip_id corresponds to a non-frequency-based trip, this field
     * should either be omitted or be equal to the value in the GTFS feed. When
     * the trip_id correponds to a frequency-based trip, the start_time must be
     * specified for trip updates and vehicle positions. If the trip corresponds
     * to exact_times=1 GTFS record, then start_time must be some multiple
     * (including zero) of headway_secs later than frequencies.txt start_time for
     * the corresponding time period. If the trip corresponds to exact_times=0,
     * then its start_time may be arbitrary, and is initially expected to be the
     * first departure of the trip. Once established, the start_time of this
     * frequency-based trip should be considered immutable, even if the first
     * departure time changes -- that time change may instead be reflected in a
     * StopTimeUpdate.
     * Format and semantics of the field is same as that of
     * GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35.
     */
    public Builder start_time(String start_time) {
      this.start_time = start_time;
      return this;
    }

    /**
     * The scheduled start date of this trip instance.
     * Must be provided to disambiguate trips that are so late as to collide with
     * a scheduled trip on a next day. For example, for a train that departs 8:00
     * and 20:00 every day, and is 12 hours late, there would be two distinct
     * trips on the same time.
     * This field can be provided but is not mandatory for schedules in which such
     * collisions are impossible - for example, a service running on hourly
     * schedule where a vehicle that is one hour late is not considered to be
     * related to schedule anymore.
     * In YYYYMMDD format.
     */
    public Builder start_date(String start_date) {
      this.start_date = start_date;
      return this;
    }

    public Builder schedule_relationship(ScheduleRelationship schedule_relationship) {
      this.schedule_relationship = schedule_relationship;
      return this;
    }

    @Override
    public TripDescriptor build() {
      return new TripDescriptor(trip_id, route_id, direction_id, start_time, start_date, schedule_relationship, super.buildUnknownFields());
    }
  }

  /**
   * The relation between this trip and the static schedule. If a trip is done
   * in accordance with temporary schedule, not reflected in GTFS, then it
   * shouldn't be marked as SCHEDULED, but likely as ADDED.
   */
  public enum ScheduleRelationship implements WireEnum {
    /**
     * Trip that is running in accordance with its GTFS schedule, or is close
     * enough to the scheduled trip to be associated with it.
     */
    SCHEDULED(0),

    /**
     * An extra trip that was added in addition to a running schedule, for
     * example, to replace a broken vehicle or to respond to sudden passenger
     * load.
     */
    ADDED(1),

    /**
     * A trip that is running with no schedule associated to it, for example, if
     * there is no schedule at all.
     */
    UNSCHEDULED(2),

    /**
     * A trip that existed in the schedule but was removed.
     */
    CANCELED(3);

    public static final ProtoAdapter<ScheduleRelationship> ADAPTER = new ProtoAdapter_ScheduleRelationship();

    private final int value;

    ScheduleRelationship(int value) {
      this.value = value;
    }

    /**
     * Return the constant for {@code value} or null.
     */
    public static ScheduleRelationship fromValue(int value) {
      switch (value) {
        case 0: return SCHEDULED;
        case 1: return ADDED;
        case 2: return UNSCHEDULED;
        case 3: return CANCELED;
        default: return null;
      }
    }

    @Override
    public int getValue() {
      return value;
    }

    private static final class ProtoAdapter_ScheduleRelationship extends EnumAdapter<ScheduleRelationship> {
      ProtoAdapter_ScheduleRelationship() {
        super(ScheduleRelationship.class);
      }

      @Override
      protected ScheduleRelationship fromValue(int value) {
        return ScheduleRelationship.fromValue(value);
      }
    }
  }

  private static final class ProtoAdapter_TripDescriptor extends ProtoAdapter<TripDescriptor> {
    public ProtoAdapter_TripDescriptor() {
      super(FieldEncoding.LENGTH_DELIMITED, TripDescriptor.class);
    }

    @Override
    public int encodedSize(TripDescriptor value) {
      return ProtoAdapter.STRING.encodedSizeWithTag(1, value.trip_id)
          + ProtoAdapter.STRING.encodedSizeWithTag(5, value.route_id)
          + ProtoAdapter.UINT32.encodedSizeWithTag(6, value.direction_id)
          + ProtoAdapter.STRING.encodedSizeWithTag(2, value.start_time)
          + ProtoAdapter.STRING.encodedSizeWithTag(3, value.start_date)
          + ScheduleRelationship.ADAPTER.encodedSizeWithTag(4, value.schedule_relationship)
          + value.unknownFields().size();
    }

    @Override
    public void encode(ProtoWriter writer, TripDescriptor value) throws IOException {
      ProtoAdapter.STRING.encodeWithTag(writer, 1, value.trip_id);
      ProtoAdapter.STRING.encodeWithTag(writer, 5, value.route_id);
      ProtoAdapter.UINT32.encodeWithTag(writer, 6, value.direction_id);
      ProtoAdapter.STRING.encodeWithTag(writer, 2, value.start_time);
      ProtoAdapter.STRING.encodeWithTag(writer, 3, value.start_date);
      ScheduleRelationship.ADAPTER.encodeWithTag(writer, 4, value.schedule_relationship);
      writer.writeBytes(value.unknownFields());
    }

    @Override
    public TripDescriptor decode(ProtoReader reader) throws IOException {
      Builder builder = new Builder();
      long token = reader.beginMessage();
      for (int tag; (tag = reader.nextTag()) != -1;) {
        switch (tag) {
          case 1: builder.trip_id(ProtoAdapter.STRING.decode(reader)); break;
          case 2: builder.start_time(ProtoAdapter.STRING.decode(reader)); break;
          case 3: builder.start_date(ProtoAdapter.STRING.decode(reader)); break;
          case 4: {
            try {
              builder.schedule_relationship(ScheduleRelationship.ADAPTER.decode(reader));
            } catch (ProtoAdapter.EnumConstantNotFoundException e) {
              builder.addUnknownField(tag, FieldEncoding.VARINT, (long) e.value);
            }
            break;
          }
          case 5: builder.route_id(ProtoAdapter.STRING.decode(reader)); break;
          case 6: builder.direction_id(ProtoAdapter.UINT32.decode(reader)); break;
          default: {
            FieldEncoding fieldEncoding = reader.peekFieldEncoding();
            Object value = fieldEncoding.rawProtoAdapter().decode(reader);
            builder.addUnknownField(tag, fieldEncoding, value);
          }
        }
      }
      reader.endMessage(token);
      return builder.build();
    }

    @Override
    public TripDescriptor redact(TripDescriptor value) {
      Builder builder = value.newBuilder();
      builder.clearUnknownFields();
      return builder.build();
    }
  }
}
